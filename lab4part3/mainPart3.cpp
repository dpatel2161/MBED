#include "mbed.h"
#include "PinDetect.h"
#include "uLCD_4DGL.h"
#include "SDFileSystem.h"
#include <iostream>
#include <string>
#include <cmath>

SDFileSystem sd(p5, p6, p7, p8, "sd");

PinDetect pb1(p18); //pushbuttons
PinDetect pb2(p19);
PinDetect pb3(p20);

uLCD_4DGL uLCD(p28, p27, p29);


enum InputType {YES, NO, NOT_PRESSED, DEC};
//enum StateType {WAIT, COPY, END};
enum StateType {WAIT, DECODE, HIGH, LOW};

InputType input = NOT_PRESSED;
StateType state = WAIT;
//---------------------------------------------------------------------------------------------------
// Callback routine is interrupt activated by a debounced pb1 hit
// That is ... this code runs with interrupt is generated by first button press
void pb1_hit_callback (void)
{
    //myled1 = !myled1;
    //mySpeaker.PlayNote(200.0,0.25,0.1);
    input = YES;
}

// ---------------------------------------------------------------------------------------------------
// Callback routine is interrupt activated by a debounced pb2 hit
// That is ... this code runs with interrupt is generated by second button press
void pb2_hit_callback (void)
{
    //myled2 = !myled2;
    //mySpeaker.PlayNote(400.0,0.25,0.1);
    input = NO;
}

// ---------------------------------------------------------------------------------------------------
// Callback routine is interrupt activated by a debounced pb3 hit
// That is ... this code runs with interrupt is generated by third button press
void pb3_hit_callback (void)
{
    //myled3 = !myled3;
    //mySpeaker.PlayNote(800.0,0.25,0.1);
    input = DEC;
}


string arrayCipher; //string of alphabet
int position; //position in receiver file

//read key file
void readCipher()
{

    FILE *fp = fopen("/sd/mydir/OTP.txt", "r");
    if(fp == NULL) {
        uLCD.printf("Open Error!!!\n");
    } else {
        fscanf(fp, "%s",arrayCipher);
    }
    fclose(fp);
}

// read position in receiver file
void readPos()
{
    FILE *fp2 = fopen("/sd/mydir/positionCipherReceiver.txt", "r");
    if(fp2 == NULL) {
        uLCD.printf("Open Error!!!\n");
    } else {
        fscanf(fp2, "%i",&position);
        fclose(fp2);
    }
}
//write position in receiver file
void writePos()
{
    mkdir("/sd/mydir", 0777);
    FILE *fp2 = fopen("/sd/mydir/positionCipherReceiver.txt", "w+");
    if(fp2 == NULL) {
        uLCD.printf("Error Open\n");
    } else {
        fprintf(fp2, "%i", position+1) ; //write line
    }
    fclose(fp2);
}
//print letter in alphabet
void printCurrentLetter(char currLetter)
{
//uLCD.cls();
    uLCD.locate(0,0);
    uLCD.text_width(5);
    uLCD.text_height(5);
    uLCD.printf("%c",currLetter);
}

//convert int to char
char toChar(int x)
{
    if (x < 0) {
        x = x + 26;
    }
    x = x % 26;
    char letter = char('A' + x);
    return letter;
}

// ---------------------------------------------------------------------------------------------------
int main()
{
    //setup push buttons
    pb1.mode(PullUp);
    pb2.mode(PullUp);
    pb3.mode(PullUp);

    // Delay for initial pullup to take effect
    wait(.01);

    // Setup Interrupt callback functions for a pb hit
    pb1.attach_deasserted(&pb1_hit_callback);
    pb2.attach_deasserted(&pb2_hit_callback);
    pb3.attach_deasserted(&pb3_hit_callback);

    // Start sampling pb inputs using interrupts
    pb1.setSampleFrequency();
    pb2.setSampleFrequency();
    pb3.setSampleFrequency();

    //generate one type pad


    // pushbuttons now setup and running

    //while loop condition
    bool getout = false;



    int counter = 0;
    string abc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    readCipher();
    while(!getout) {
        wait(0.1);


        switch(state) {
            case (HIGH):
                //move up in alphabet
                counter = (counter + 1) % 26;
                printCurrentLetter(abc[counter]);
                state = WAIT;

                //calculate next state
                break;
            case (WAIT):
                //calculate the next state
                if (input == YES) {
                    state = HIGH;
                    input = NOT_PRESSED;
                } else if (input == NO) {
                    state = LOW;
                    input = NOT_PRESSED;
                } else if (input == DEC) {
                    state = DECODE;
                    input = NOT_PRESSED;
                    break;
                case (LOW):
                    //move down in alphabet
                    counter = (counter - 1);
                    if (counter < 0) {
                        counter = 25;
                    }
                    printCurrentLetter(abc[counter]);
                    state = WAIT;
                    break;
                case (DECODE):
                    //decode letter in message
                    readPos();
                    uLCD.locate(0,2);
                    uLCD.text_width(5);
                    uLCD.text_height(5);
                    char letter2 = toChar(abc[counter] - arrayCipher[position]);
                    uLCD.printf("%c", letter2);
                    writePos();
                    state = WAIT;

                    break;

                } //end of switch statement

        } //end while loop
    }
} //end main